---
title: TCP协议深度解读
cover: https://img.51santi.uk/file/d58725cda9293628d49a7.jpg
# cover: https://img.51santi.uk/file/42a0b32064d3cfe2c94c4.jpg
swiper_index: 10
top_group_index: 10
background: '#fff'
date: 2024-07-19 09:06:02
updated:
tags:
categories:
keywords:
description:
top: 3
top_img:
comments:
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
ai:
---

# 位、字节、字
## 1、位（bit）
来自英文bit，名叫比特，表示二进制位。**位是计算机内部数据存储的最小单位**，11011011是一个8位二进制。一个二进制位只能表示1或0两种状态；二个二进制位可以表示00、01、10、11四种状态；三位二进制数可以表示八种状态。。。。
## 2、字节（byte）
字节来自英文byte，叫‘拜特’， 习惯用大写的‘B’表示
**字节是计算机中数据处理的基本单位。**计算机中以字节位单位存储和解释信息，规定一个字节由八个二进制位构成，即1个字节等于8个比特（1Byte=8bit）。八位二进制数最小位00000000，最大位11111111；通常1个字节可以存入一个ASCII码，2个字节可存放一个汉字国标码。

## 3、字
**计算机进行数据处理时，一次存取、加工和传输的数据长度称为字（word）。**一个字通常由一个或多个（一般是字节的整数位）字节构成。例如286微机的字是由2个字节组成，他的字长位16；486微机的字由4个字节组成，他的字长位32位。 计算机的字长决定了cpu一次操作处理实际位数的多少，由此可见计算机的字长越大，其性能越好。
 > 在存取器中，通常每个单元存储一个字，因此每个字都是可以寻址的。字的长度用位来表示
> 在计算机的运算器、控制器中，通常是以字为单位进行传送的。例如，送往控制器去的字是指令，而送往运算器去的字就是一个数。在计算机中作为一个整体被存取、传送、处理的二进制数字符串叫做一个字或单元，每个字中二进制位数的长度，称为字长。一个字有若干个字节组成，不同的计算机系统的字长是不同的，常见的有8位、16位、32位、64位等，字长越长，计算机一次处理的信息位就越多，精度就越高，字长是计算机性能的一个重要指标。目前主流微机都是32位机。注意字与字长的区别，字是单位，而字长是指标，指标需要用单位去衡量。就像生活中重量与公斤的关系，公斤是单位，重量是指标，重要需要用公斤加以衡量。
> 8个位（bit）称为一个字节（byte），两个字节称为一个字（word），两个自称位一个双字（dword），两个双字称为一个四字（qword）

### 3.1字长
计算机的每个字所包含的位数称位字长。根据计算机的不同，字长有固定的和可变的两种。固定字长，即字长度不论什么情况都是固定不变的；可变字长，则在一定范围内，其长度是可变的。

**计算机的字长是指它一次可处理的二进制数字的数目。**计算机处理数据的速率，自然和它一次能加工的位数以及进行运算的快慢有关。如果一台计算机的字长是另一台计算机的两倍，即使灵台计算机的速度相同，在相同的时间内，前者能做的工作是后者的两倍。

一般来讲，大型计算机的字长位32-64位，小型计算机位12-32位，而微型计算机为4-16位。字长是衡量计算机性能的一个重要因素。

### 3.2字块
在信息处理中，一群字作为一个单元来处理的称为“字块”，也称“字组”。例如，储存于磁盘的一个磁道上的字群就称为一个字块，在磁带上通常每120个字符就间隔一个字块标志，也称为一个字块。块与块之间一般留1.27-2.54厘米的间隔。在大容量存储中，信息都是以字块为单位而存入的，因此只有字块才是可选址的。目前，在告诉缓存技术中引入了“字块”的概念。

# TCP报文（标准长度20字节）
TCP(Transmission Contorl Protocol) 传输控制协议是一种面向连接的、可靠的、基于字节流的传输层协议
TCP报文格式如下：
![6ef4a306cf7592744035f.jpg](https://img.51santi.uk/file/6ef4a306cf7592744035f.jpg#pic_left)
TCP数据包每次能够传输的最大长度=MTU(1500B)-IP头(20B)-TCP头(20B)=1460Bytes.
![8c19c6f54117839a710ad.png](https://img.51santi.uk/file/8c19c6f54117839a710ad.png#pic_left)
**源端口号**（2字节）：
  d5 df (54751)
**目的端口号**（2字节）：
  22 b8  (8888)
![72f86baf8867b1aca86a5.png](https://img.51santi.uk/file/72f86baf8867b1aca86a5.png)
TCP报文头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。
**序列号**（4字节）：
  37 59 56 75
  用来标识TCP发送端向TCP接收端发送的数据字节流
  **确认序列号**（4字节）
  由于该报文为SYN报文，ACK标志位0，故没有确认序号（ACK标志位1时确认序列号才有效）
  一旦建立连接，该值将始终发送（同ACK标志）
  **头部长度**（4位）：报文头长度（单位：位）/32
  1000 (转化为10进制为8， 8*32/8 = 32，该报文包头长度为32个字节 )
  存在该字段是因为TCP报头任选字段长度可变，四位TCP报头长度为0101.
  报头不包含任何任选字段则长度为20字节；4为能表示的最大值为1111，转化为10进制为15， 15*32/8 = 60，故报头最大长度为60字节；
  **标志位**（12位）：
    0000 00010010
    Reserved：
      

    000~ ~~~~~~~~
    ECN（Explicit Congetsion Notification）：

    ~~~0 ~~~~~~~~ = N / NS / Nonce Sum：有效排除潜在的ECN滥用，RFC 3540

    ~~~~ 0~~~~~~~ = C / CWR（Congestion Window Reduced）：拥塞窗口减少标志

    ~~~~ ~0~~~~~~ = E / ECE / ECN-Echo：ECE / ECN标志

    Control Bits：

    ~~~~ ~~0~~~~~ = URG / Urgent：紧急指针有效性标志

    ~~~~ ~~~1~~~~ = ACK / Acknowledgment：确认序号有效性标志，一旦一个连接建立起来，该标志总被置为1，即除了请求建立连接报文（仅设置Syn标志位为1），其它所有报文的该标志总为1

    ~~~~ ~~~~0~~~ = PSH / Push：Push标志*（接收方应尽快将报文段提交至应用层）*

    ~~~~ ~~~~~0~~ = RST / Reset：重置连接标志

    ~~~~ ~~~~~~1~ = SYN / Syn：同步序号标志（发起一个新的连接）

    ~~~~ ~~~~~~~0 = F / Fin：传输数据结束标志/释放一个连接
  
  **窗口大小**（2字节）：窗口大小标志着TCP缓冲区内部剩余空间的大小，起到流量控制的作用。如果窗口满了，那么这个时候是不允许数据接口的，后面到达的数据会被丢失。
  20 00 （00100000 00000000） = 8192
  由于2字节能够表示的最大正整数为65535，故窗口最大值为65535
  **校验和**（2字节）：校验和覆盖整个TCP报文端；强制字段，由发送端填充，CRC校验。由接收端进行验证数据的时候如果校验不通过。此处的校验和不仅仅校验TCP首部，还校验数据部分。
   2e 2f
   **紧急指针**（2字节）：当urgent标志为1时，紧急指针才有效，标识着哪部分的数据为紧急数据
    00 00
    **任选字段**（0-40字节）
== **【重要的字段】：**==

 - *源端口号与目的端口号：标识了发送方与接收方的地址*，IP地址和端口号合称位套接字。
 - **序列号和确认号：** 32位序列号与32位确认号：序列号与确认号可以理解成两个通信进程在收发数据的时候互相应答的信息。比如说，A进程从序列号1000开始给B进程发数据，发送五个数据。那么在B收到数据回复的时候，这里A的确认序列号应该是从1006，如果是1003，那意味着1004、1005数据包没有收到，于是A启动重发机制。这也保证了数据的可靠性，也是TCP特点之一。序列号是进程发送消息的号码，而确认号是期望目的进程返回的号码。进行对比，从而验证数据包是否到达。
# 三次握手
  在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。
 ![56fae17da4d16e1522f3b.png](https://img.51santi.uk/file/56fae17da4d16e1522f3b.png)
 - 第一次握手：client先产生一个初始序列号seq =
   ISN（C），作为syn并将该数据包发送给server，client进入SYN_SENT状态，等待server确认
 - 第二次握手：server收到数据包后也发送自己的SYN报文作为响应，并初始化序列号seq =
   ISN（S），为了确认client的seq，server将client发送的seq加1，作为ACK发送给client，
   Server进入SYN_RCVD状态。（SYN为synchronize的缩写， ACK为acknowledgment的缩写）
 - 第三次握手：为了确认Server的SYN，Client将server发送的seq加1，作为ACK发送给server。client和server进入ESTABLISHED状态，完成三次握手，随后client与server之间可以开始传输数据了。

通过这样的三次握手，客户端与服务端建立可靠的双工的连接，开始传送数据。三次握手的最主要目的是保证连接是双工的，可靠更多的是通过重传机制来保证的。
##   半连接、半打开、半关闭状态

 - **半连接状态：**发生的TCP三次握手过程中，客户端向服务器发起连接，服务器也进行了回应，但是客户端却不进行3次握手.
 - **半打开状态：**在TCP连接中，如果某一段关闭了连接或者是异常关闭，则该连接处于半打开状态。解决半打开问题：引入心跳机制就可以察觉半打开状态。
 - **半关闭状态：**当TCP连接中客户端向服务端发送FIN请求关闭，服务端回应ACK之后，并没有立即发送FIN给客户端，客户端就处于半关闭状态，此时客户端可以接收服务器发送的数据，但是客户端已经不能向服务器发送数据。

## SYN flood攻击
在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect)。此时服务器处于SYN_RCVD状态。当收到ACK后，服务器转入ESTABLISHED态。
![028795667155d0c093de4.jpg](https://img.51santi.uk/file/028795667155d0c093de4.jpg)

  SYN攻击就是攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。

```bash
  //检测是否被Syn攻击
  netstat -n -p TCP | grep SYN_RCVD
```
  一般较新的TCP/IP协议栈都对这一过程进行修正来防范Syn攻击，修改tcp协议实现。主要方法由SynAttackProtect保护机制、SYN cookies技术、增加最大半连接和缩短超时时间等。但是不能完全防范Syn攻击。

## 四次挥手
![d6d1e37adf1f4b9482b21.jpg](https://img.51santi.uk/file/d6d1e37adf1f4b9482b21.jpg)

 - 第一次挥手：client发送一个FIN， seq=k，
   用来关闭client到server的数据传送，client进入FIN_WAIT_1状态；
 - 第二次挥手：server收到FIN后，发送一个ACK（k+1）给client，确认序列号为收到序号+1（与SYN相同，一个FIN占用一个序号），server进入CLOSE_WAIT状态；
 - 第三次挥手：server发送一个FIN， seq=L，
   用来关闭server到client的数据传送，server金融LAST_WAIT状态
 - 第四次挥手：client收到FIN后，client进入TIME_WAIT状态，接着发送一个ACK(L+1)给server，
   确认序号为收到序号+1，server进入CLOSED状态，完成四次挥手。

### 1、为什么建立连接是三次握手，而关闭连接却是四次挥手呢？
在三次握手是，服务器可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送，但是四次挥手时，服务端发送的FIN与ACK是分开发送的。

如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。


<div class="video-container">
[up主专用，视频内嵌代码贴在这]
</div>

<style>
.video-container {
    position: relative;
    width: 100%;
    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */
}

.video-container iframe {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}
</style>
